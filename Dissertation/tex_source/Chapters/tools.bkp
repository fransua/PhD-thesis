%%% tools.tex --- 

%% Author: garamonfok@gros
%% Version: $Id: tools.tex,v 0.0 2011/10/09 18:39:32 garamonfok Exp$

\section{Overview on the detection of selective pressures at genomic level}
\label{sec:overv-detect-select}

In the pipeline leading to the identification of selective pressures acting on genes (see section: \textbf{\nameref{sec:pipel-detect-molec}}, in the Introduction), the most decisive steps are surely the first ones, the definition of homologous groups of transcripts, and their alignment. However the essentially technical aspect of this steps is often underestimated. In the sections above, we are going to review the classical methodology and propose some solutions in order to improve its accuracy.

\subsection{The selection of homologous sequences}
\label{sec:select-homo-sequ}

The first step in an analysis of selective pressure acting in a gene, is the definition of a set of homologous genes. Two parameters have to be taken into account here, the number of sequence to compare and the degree of similitude the comparison should accept. From the recommendations of Ziheng Yang in PAML's ``FAQs''\cite{Yang2007}:
\begin{itemize}
\item The number of sequences: a minimum of 4 to 5 sequences in optimal conditions optimal sequence divergence.
\item The optimal divergence: The sum of $dS$ over all branches in a tree sums more than 0.5. At the other edge, the maximal divergence that can be handled to reconstruct an accurate phylogenetic tree, is assumed to be limited by the saturation of synonymous sites. However since, the emergence of maximum likelihood in phylogenetic analysis, synonymous saturation is considered to be problematic from 30-40\% sequence divergence. And this degree of divergence basically moved the limitation to other problems, as the accuracy of the alignment, or the heterogeneity of nucleotide frequencies that would bias the substitution process in some species in relation to others \cite{Yang1998b}.
\end{itemize}

In other words, being able to align fairly a set of at least 4-5 sequences summing a $dS$ over 0.5 is generally sufficient to start building a phylogenetic trees and estimate selective pressures over it.

Over these classical considerations, an other point that may be taken into account concerns the selection of the ``best'' transcript. The accepted approximation that consists in using the longest transcript of each gene in comparative studies, may be reconsidered in specific cases.

\subsection{The alignment}
\label{sec:alignment}

The first aspect to consider when aligning coding sequences is its intrinsic structure, the three nucleotides constituting a codon should not be separated in the alignment process. This consideration plus the fact that alignments realized based on amino-acid sequence are generally more accurate, leads to the conclusion that a good solution to align coding-sequences is to use their translation onto protein.

When one is called upon to align sequences the variety of choice in software might be bewildering. This, specially knowing that misaligned columns have high chances to pass positive selection tests. Even if some multialignment tools seem to stand out in terms of accuracy and computation time (we can cite Muscle \cite{Edgar2004}, MAFFT \cite{Katoh2005}, DIALIGN-TX \cite{Subramanian2008}, ProbCons \cite{Do2005} or T-COFFEE\cite{Notredame2010}) the congruence between these may vary.

Some works were made in order to provide a classification of the accuracy of these tools \cite{Plyusnin2012} using the BAliBASE \cite{Bahr2001} dataset. However, even if some aligners seem to globally stand out above others (ProbCons or T-Coffee), the accuracy may be highly dependent on the data used \cite{Edgar2006}.

In the pipeline leading to the identification of selective pressures among genes, the alignment step, even if crucial, is usually the fastest in terms of computational time. Thus, the solution proposed in \cite{Edgar2006} may be taken into consideration. This solution consists in using the consensus solution of several aligners that are based in different algorithms (the example proposed in the review is T-COFFEE, ProbCons and MUSCLE). The consensus alignment can be obtained with the M-COFFEE tool for example. This strategy would lead to discard, as to variable, those sites which placement in the alignment is varying depending on the tool used.

Finally, and once obtained a fair alignment, a last step is necessary in order remove columns (or rows if possible) of the alignment that presents unrealistic variation. This step can be achieved, for example, with TrimAl \cite{Capella-Gutierrez2009}.

\subsection{Model testing and phylogenetic inference}
\label{sec:model-test-phyl}

In the pipeline leading to the detection of selective pressures at molecular level, the phylogenetic relationship between sequences may be known. This step however may be skipped in the case we are working with one-to-one orthologs, and we are confident about a known species tree. Otherwise, the phylogeny must be constructed.

As with the alignment step, the reconstruction of a phylogeny is generally more accurate when dealing with amino acid sequences. The only exception being the case where sequences are too close to present differences in their amino-acid sequences.

Distance between sequences are calculated according to a model. In the case of nucleotidic models, from the most simple model Jukes and Cantor (JC) \cite{Jukes1969} --that assumes equal transition and transversion rates as well as equal base equilibrium frequencies--, to the most complex model, the General Time-Reversible (GTR) model \cite{Rodriguez1990} --that accounts for different rates for each kind of possible substitutions for each nucleotide--, a whole range of models can be used to weight the changes occurring between two sequences. In the case of amino-acid sequences several evolutionary models are also available, this time based on empirical data.

Whatever the case, nucleotide or amino-acid sequences, we have to decide which model is able to explain better the substitutions observed between sequences. For now, the most accepted methodology consists in comparing model's likelihood through LRT if model are nested or their Akaike (or AIC) score \cite{Akaike1974} otherwise (for amino-acid models).

Although this methodology is successfully finding the most likely model explaining the successive substitutions differentiating sequences, the cost in terms of computational time is high. Some approximations, however can be used in order to accelerate the process, using fixed topology build by neighbor-joining (NJ) are believed to be good approximations in order to estimate the best model \cite{Posada2001}. 

Once identified the evolutionary model with best fit, the phylogeny can be constructed. We are not going to enter deep into this topic, however we would like to point out that, if the reconstruction fails to solve, with enough confidence, each node of the phylogeny, a good option is to keep the tree ``multi-forked''. Using an approximate solution is better than betting for a solution with poor statistical support.

\subsection{Testing for evolutionary scenarios in protein coding genes}
\label{sec:test-evol-scen}

Once formulated, an evolutionary hypothesis can be formulated and tested. Classical methodology for testing evolutionary hypothesis involves the use of programs like CodeML from the PAML package \cite{Yang2007} or the SLR program \cite{Massingham2005} (among others). However these tools are designed to be used for the study of one or very few trees. The preparation of the data, the configuration file and the successive test needed in order to find with confidence the optimal values of each of the parameters. At the other edge, the interpretation and integration of the results is also complicated given the quantity of information usually produced.

This section is dedicated to a solution that we brought out in order to ease the analysis of selective pressures at genomic scale, with examples of the classical evolutionary tests in protein-coding regions.

\subsubsection{Codon substitution model}

The detection of selective pressures in protein-coding regions of the genomes consists basically in the count of synonymous and non-synonymous changes between pairs of sequences. More precisely the distance between two codons is calculated according to Markov-chain model with, as state of space, the instantaneous proportion of each codon, and as substitution-rate matrix, $Q=\{q_{ij}\}$. $q_{ij}$ being the instantaneous rates from codon $i$ to codon $j$. The model commonly used is this simplification of Goldman and Yang \cite{Goldman1994}:

\rowcolors{1}{white}{white}
\begin{equation} \label{eq:subst-rate-matrix}
  q_{ij} = 
  \left\{% big bracket at left
    \begin{array}{ll} % like tables, 2 left-aligned columns
      0,                 & \mbox{if $i$ and $j$ differ at 2 or 3 codon positions.}        \\
      \pi_j,             & \mbox{if $i$ and $j$ differ by 1 synonymous transversion.}     \\
      \kappa\pi_j,       & \mbox{if $i$ and $j$ differ by 1 synonymous transition.}       \\
      \omega\pi_j,       & \mbox{if $i$ and $j$ differ by 1 non-synonymous transversion.} \\
      \omega\kappa\pi_j, & \mbox{if $i$ and $j$ differ by 1 non-synonymous transition.}
    \end{array}%
  \right. % nothing at right
\end{equation}

With $\pi_j$ the equilibrium frequency of codon $j$, $\kappa$ the ratio of transition over transversions (see \autoref{fig:transi-transv}) , $\omega$ the ratio of non-synonymous over synonymous mutations.

\begin{figure}[htpb]
  \centering
  \begin{tikzpicture}[node distance=2.3cm, auto]

    \node (A) {A};
    \node (G) [right of=A] {G};
    \node (C) [below of=A] {C};
    \node (T) [below of=G] {T};
    \draw[line width=0.4mm, <->] (A) to node {}(T);
    \draw[line width=0.4mm, <->] (C) to node {}(G);
    \draw[line width=0.4mm, <->] (A) to node {}(C);
    \draw[line width=0.4mm, <->] (T) to node {}(G);
    \draw[line width=0.4mm, <->, dashed] (A) to node {\scriptsize transition}(G);
    \draw[line width=0.4mm, <->, dashed] (T) to
    node {\scriptsize transition}(C);
    \draw[line width=0.3mm, decorate,decoration={brace,amplitude=0.3cm,raise=0.2cm}](G)--(T)
    node [midway,xshift=0.5cm,yshift=0.03cm] {\scriptsize transversions};
  \end{tikzpicture}
  \caption[Transition and transversion]{
    \textbf{Transition and transversion.}\\ Schema defining the different kinds of substitutions between each nucleotide.}
  \label{fig:transi-transv}
\end{figure}


The different codon models corresponds to different assumptions made on the distribution of equilibrium codon frequencies $\pi_j$. Most common codon models assume either
\begin{inparaenum}[ 1-]
  \item that each codon has the same frequency (``F1$\times$4'' in CodeML -- 1 degree of freedom)
  \item codon frequency are estimated based on the observed frequencies of nucleotides (``F3$\times$4'' in CodeML -- 3 degrees of freedom)
  \item codon frequencies is different for each codon (``F61'' in CodeML -- 59 or 60 degrees of freedom)
\end{inparaenum}.

To relate the model to real data over time ($t$), we need to define a transition-probability for any time, and for all possible $i$ and $j$ codons ($p_{ij}(t) = Pr \{X(t)=j|X(0)=i\}$). The matrix of this transition-probability ($P(t)$) can be calculated as: 
\begin{equation}\label{eq:trans-prob-matrix}
  P(t) = \{p_{ij}(t)\} = e^{Qt}
\end{equation}

\autoref{eq:subst-rate-matrix} gives us the major parameters that are affecting the count of changes between 2 codons (plus the time \autoref{eq:trans-prob-matrix}). For real data, within a phylogenetic tree, this estimation has to be done for each codon, and at each internal node. Solutions to solve this problem are, today, mainly centered around maximum likelihood methods, using Felsenstein's pruning algorithm \cite{Felsenstein1981}.

\subsubsection{Overview of major/classical evolutionary models}
\label{sec:overv-majorcl-evol}

We have seen in previous section the parameters to be considered in order to compute distances between sequences. However, the quantity of parameters needed to be estimated for each codon and at each internal node may lead to an over-fit of the model. In order to estimate the importance of the optimization of a given parameter, a likelihood-ratio test can be performed. For example, in previous section we mentioned the most frequently used codon models (F1$\times$4, F3$\times$4 and F61), a solution to decide which one of this model would explain with more accuracy the changes observed between codons, we can compute their likelihood over a given dataset.

An other example lies in the assumption of different selective pressures, either over branches or over sites. Selective pressures (related to the $\omega$ ratio) can be optimized according to different hypotheses of heterogeneity. In this section we will focus on three main groups of models, site, branch and branch-site models.

\paragraph{Site models}
\label{sec:site-models}

Site models assume that all branches of a given phylogenetic tree are evolving at the same $\omega$ rate but allow different selective pressures to occur along the alignment. These models are useful in order to quickly see which parts of a sequence are under strong selective constraints in the studied group of species. Several strategies are available in order to obtain the shape of $\omega$ values among sites, among them we will mention two of the most used. \textbf{First}, the one using a ``sitewise likelihood-ratio'' methodology implemented in the SLR program \cite{Massingham2005} that computes a LRT at each site $i$: $\Lambda_i = 2\times(l_i(1) - l_i(\hat{\omega_i}))$, with $l_i(1)$, the likelihood of the null model assuming that $\omega = 1$, and $l_i(\hat{\omega_i})$ the likelihood of the alternative model letting the estimate of $\omega_i$ free. \textbf{Second}, the site models implemented in CodeML \cite{Yang2007} that are based on the definition of a prior, that segregates different categories of sites based on the distribution of the random variation of $\omega$ values (e.g.: category of sites with $\omega>1$), followed by the assignation of a value of probability, for each site, to belong to one of these categories.

\paragraph{Branch models}
\label{sec:branch-models}

These models are orthogonal to site models in the sense that $\omega$ rate is not allowed to vary along the alignment, while it can be estimated independently for each branch of the phylogeny. Most simple (and most unrealistic) branch model, the ``\textit{M0}'' model, assumes that all branches are evolving at the same rate (and same for sites as it is a branch model), calculating a unique value of $\omega$ for the whole phylogeny. At the other edge the most complex model, the ``\textit{free-ratio}'' model estimates a different value of $\omega$ for each branch of the phylogeny. Also, both \textit{M0} and \textit{free-ratio} models might be either unrealistic or a classical case of over-fitting model, they are useful as respective null or alternative model when testing for a given evolutionary scenarios.

Overall, the assumption made by branch models are dangerous as high values of $\omega$ detected are usually due to the counterbalanced effect of conserved and accelerated sites. However, it is a useful for detecting differences between the evolutionary rates of sequences taken either individually, or grouped together (e.g. in clades). A classical example of the use of these models, is the detection of different selective pressures occurring between colobines and hominids' lysozyme protein \cite{Yang1998a}.

\paragraph{Branch-site models}
\label{sec:branch-site-models}

As the name suggests, these models represent a compromise between previous two groups of models. More precisely, phylogenetic information is used to contrast differences in rates of a given site. This model is usually used to detect, or contrast, sites under a characteristic selective pressure. The contrast being done between to parts of a phylogenetic tree, generally referred to as foreground and background branches.  Foreground branches having an extra class of sites allowing $omega$ to be higher than 1. In a classic branch-site model (\textit{branch-site A} in CodeML), foreground branches are fitted to a model similar to the \textit{M2} model, while background branches to a model similar to \textit{M1} model. These models are more realistic then sites or branch models, and are the most reliable for tests of positive selection.

\subsubsection{Testing for the best evolutionary model}
\label{sec:test-best-evol}

Beyond the descriptive use of the models described above, models can be compared through LRT in order to evaluate --with statistical significance-- the importance of the optimization of a given parameter. This methodology, for example, has been extensively used in each of the groups of models described above in the context of positive selection test. Here are listed some examples of the most popular tests that can be done by comparing the fit of different evolutionary models.

The comparison of the fit of the evolutionary models reviewed above to a given dataset by mean of their likelihood.

\paragraph{Test of positive selection and relaxation in sites}
\label{sec:test-posit-select}

As we have seen above, in CodeML, a site analysis basically consists in classifying all the sites in an alignment into the categories of sites defined by the model. In the context of the identification of positively selected sites, model can be classified in 2 categories, neutral models and positive-selection models. The difference between them being that positive-selection models have an extra category of sites that allows $\omega$ to be higher then 1. Models, being nested, a LRT can be conducted between them (with usually 1 degree of freedom that corresponds to the estimation of the extra class of sites). If positive-selection model wins, than sites that belongs to last category (with $\omega > 1$) are considered to be truly under positive selection.

A classical positive selection test is done by comparing model M1a (neutral, with 2 categories of sites: $0<\omega_0<1$ and $\omega_1=1$) with model M2a (positive selection, with same categories of M1a plus $\omega_2>1$).

\paragraph{Test of different selective regimes in branches}
\label{sec:test-diff-select}

These models are perhaps the most unrealistic at the time to test for positive selection, however they still are useful to compare and differentiate selective regimes in branches. For example, one can formulate the hypothesis that a given clade is undergoing an acceleration in mutation rate compared to the rest of the phylogeny, and test this hypothesis.


\begin{figure}[htpb]
  \centering
  \begin{tabular}{l l l}
    \textbf{A} & \textbf{B} & \textbf{C} \\
    \scriptsize
    \begin{tikzpicture}[edge from parent path={
        (\tikzparentnode.east) |- (\tikzchildnode.west)}
      ]
      \node (root) {} [grow=right]
      child [rounded corners=5mm]{
        child [rounded corners=0mm]{node {Orangutan}}
        edge from parent [style={draw=black,line width=.8mm}] node [below=2.5mm,right=5mm] {$\omega_O$}
      }
      child [rounded corners=5mm]{
        edge from parent [style={draw=black,line width=.8mm}]
        child [rounded corners=5mm] {
          node {Chimp}
          edge from parent [style={draw=black,line width=.8mm}] node [below=2.5mm,right=.5mm] {$\omega_C$}
        } 
        child [rounded corners=5mm] {
          node {Human}
          edge from parent [style={draw=black,line width=.8mm}] node [above=2.5mm,right=.5mm] {$\omega_H$}
        }
      };
    \end{tikzpicture} &
    \scriptsize
    \begin{tikzpicture}[edge from parent path={
        (\tikzparentnode.east) |- (\tikzchildnode.west)}
      ]
      \node (root) {} [grow=right]
      child [rounded corners=5mm]{
        child [rounded corners=0mm]{node {Orangutan}}
        edge from parent [style={draw=black,line width=.8mm}] node [below=2.5mm,right=5mm] {$\omega_O$}
      }
      child [rounded corners=5mm]{
        edge from parent [style={draw=black,line width=.8mm}]
        child [rounded corners=5mm] {
          node {Chimp}
          edge from parent [style={draw=gray,line width=.8mm}] node [below=2.5mm,right=.5mm] {$\omega_C$}
        } 
        child [rounded corners=5mm] {
          node {Human}
          edge from parent [style={draw=gray,line width=.8mm}] node [above=2.5mm,right=.5mm] {$\omega_H$}
        }
      };
    \end{tikzpicture}
    &
    \scriptsize
    \begin{tikzpicture}[edge from parent path={
        (\tikzparentnode.east) |- (\tikzchildnode.west)}
      ]
      \node (root) {} [grow=right]
      child [rounded corners=5mm]{
        child [rounded corners=0mm]{node {Orangutan}}
        edge from parent [style={draw=black,line width=.8mm}] node [below=2.5mm,right=5mm] {$\omega_O$}
      }
      child [rounded corners=5mm]{
        edge from parent [style={draw=black,line width=.8mm}]
        child [rounded corners=5mm] {
          node {Chimp}
          edge from parent [style={draw=gray!45,line width=.8mm}] node [below=2.5mm,right=.5mm] {$\omega_C$}
        } 
        child [rounded corners=5mm] {
          node {Human}
          edge from parent [style={draw=gray!90,line width=.8mm}] node [above=2.5mm,right=.5mm] {$\omega_H$}
        }
      };
    \end{tikzpicture}\\
  \end{tabular}
  \caption[Simple example of allowing / disallowing different $\omega$ rates in tree.]{
    \textbf{Simple example of allowing / disallowing different $\omega$ rates in tree.}\\
    A simple phylogeny is represented here, the colors of the branches represents the different estimations of $\omega$. In (\textbf{A}), the $\omega$ value of all the branches is the same ($\omega_O = \omega_C = \omega_H$), in (\textbf{B}) the $\omega_O$ of the Orangutan, is different from the rest of the tree ($\omega_O \neq \omega_C = \omega_H$), and in (\textbf{C}) each branch has a different value of $\omega$ ($\omega_O \neq \omega_C \neq \omega_H$). Figure adapted from \cite{Yang2006}.
  }
  \label{fig:example_branch}
\end{figure}

\autoref{fig:example_branch} is an example of methodology over a simple phylogeny representing 3 sequences of Human, Chimp and Orangutan. Each of (\textbf{A}), (\textbf{B}) and (\textbf{C}) in the figure, represents different branch models. (\textbf{A}) is the simplest branch model, one $\omega$ is estimated for all branches, in (\textbf{B}) 2 values of $\omega$ are estimated (we thus have one extra parameter in comparison with (\textbf{A})) and in (\textbf{C}) 3 values of $\omega$ are calculated (again one parameter more than previous model). The comparison by LRT between models (\textbf{A}) and (\textbf{B}) would thus determine if the evolutionary rate calculated for Orangutan sequence is significantly different from the rest of the tree. And, in the same way, the comparison between (\textbf{B}) and (\textbf{C}) is indeed testing if each branch is evolving at different rates.

\paragraph{Test of positive selection and relaxation in sites of a given set of branches}
\label{sec:test-posit-select-1}

This test is perhaps the most sensitive for detecting positive selection in protein-coding genes. We have seen that, in branch tests, one protein would be detected to be under positive selection only if the average $\omega$ over all sites is higher than 1, however we can easily imagine the case where only few sites are evolving fast in a context of global purifying selection for the rest of the protein. In the same way, in the case of site tests, the $\omega$ value of a given site is averaged over all branches. However both of these tests were successful to detect positive selection in protein-coding genes, we could expect that in most of the cases significant accelerations of $dN$ in relation to $dS$ would only affect some sites in a given lineage. This is the main reason that pushes Yang and Nielsen \cite{Yang2002} to implement a new test for positive selection able to detect few sites in a particular lineage. Originally the test consists in comparing the branch-site model A (bsA) to the model M1a -- this test is often referred to as ``test I''. From the specification of bsA model (see \autoref{tab:modelA}), we see that the only difference with model M1a, is the presence of sites evolving at $\omega_2$ rate in foreground branches.

\begin{table}[htpb]
  \rowcolors{2}{white}{lightgray}
  \centering
  \scriptsize
  \begin{tabular}{l c c c}
    \hline
    \textbf{Site class} & \textbf{Proportion}        & \textbf{Background $\omega$} & \textbf{Foreground $\omega$} \\ \hline
    0                   & $p_0$                      & $0<\omega_0<1$               & $0<\omega_0<1$               \\
    1                   & $p_1$                      & $\omega_1=1$                 & $\omega_1=1$                 \\
    2a                  & $(1-p_0-p_1)p_0/(p_0+p_1)$ & $0<\omega_0<1$               & $\omega_2>1$                 \\
    2b                  & $(1-p_0-p_1)p_1/(p_0+p_1)$ & $\omega_1=1$                 & $\omega_2>1$                 \\ \hline
    
  \end{tabular}
  \caption[$\omega$ ratios assumed in model branch-site A]{
    \textbf{$\omega$ ratios assumed in model branch-site A.}\\
    In a phylogenetic tree where branches are divided in 2 categories, ``background'' and ``foreground'', in order to allow over them different selective pressures, sites are allowed to evolve at $\omega$ rates higher than 1 only in foreground branches. $p_0$ and $p_1$ are the proportion of sites evolving respectively at rates $\omega_0$ and $\omega_1$.
  }
  \label{tab:modelA}
\end{table}

Even if theoretically the test between bsA and M1a (test I) seems robust, simulations study found high proportions of false positive \cite{Zhang2004}, and conducted to the implementation of new test \cite{Zhang2005b}. This new branch-site tests (referred to as ``test II'') consists in the comparison of 2 branch-site models, one with $omega_2 >1$ (bsA) and the other, namely branch-site A1 (bsA1) with $\omega_2=1$. bsA1 being here the null model. A gene would be considered to be under positive selection if the fit of bsA model is better than bsA1.

As, the first branch-site test (test I) is considered to bring high proportion of false positives, it is often used in order to detect relaxed constraints in genes (see \autoref{fig:branch-site}). Thus, a protein-coding gene should be considered to be under positive selection if it passes test I, and considered to be under relaxed constraints if it passes test II but not test I.

\begin{figure}[htpb]
  \centering
  \scriptsize
  \def\firstcircle{(0,0) circle (1.5cm)}
  \def\secondcircle{(0:2cm) circle (1.5cm)}
  \begin{tikzpicture}
    \begin{scope}[shift={(6cm,0cm)}]
      \fill[gray] \secondcircle;
      \fill[lightgray] \firstcircle;
      \draw [lightgray] \firstcircle  node [text width=4em, text centered,black] () {bsA \\ vs \\ bsA1\\(test II)};
      \draw [gray] \secondcircle node [text width=4em, text centered,black] () {bsA \\ vs \\ M1a\\(test I)};
    \end{scope}
  \end{tikzpicture}
  \caption[Branch-site tests for the detection of positive selection and relaxation.]{
    \textbf{Branch-site tests for the detection of positive selection and relaxation.}\\
    Circles here represent positive results of the LRT between branch-site model A (bsA) versus branch-site model A1 (bsA1) (``Test II'') on the left, and bsA versus site model M1a on the right (``Test I''). The color represents the set of genes that should be considered to be under positive selection (light gray--left) or under relaxation (dark gray--right).}
  \label{fig:branch-site}
\end{figure}


\section{ETE's Evol extension}
\label{sec:etes-evol-extension}

In previous sections we have seen different evolutionary models and tests, mainly defined in the CodeML program, however it is important to contrast that these models are standards and other programs or packages offers different implementations to achieve similar tests \cite{Knight2007,Pond2005}.

This section is dedicated to what can be either a genomic solution or at least a simplification of the methodology for the determination of selective pressures and the test of evolutionary hypotheses. This solution passes through the use of ETE \cite{Huerta-Cepas2010}, and more particularly of the ``Evol'' extension, that allows to call CodeML and SLR programs. Results of such analysis are embedded in ETE's Tree \myglspl{object} and from there can be contrasted (evolutionary model comparison), visualized or summarized.

\subsection{Implementation}
\label{sec:implementation}

ETE is a python package originally designed for the manipulation, analysis and visualization of phylogenetic trees. Ahead of the most general Tree \mygls{class}, stands, among others, the PhyloTree (from the ``Phylo'' extension) that implements specific algorithms to deal with phylogenetic trees. As most useful functions, we can cite the abilities to:
\begin{itemize}
\item link a tree to an alignment
\item infer evolutionary events (speciation or duplication) through different algorithms
\item relatively date nodes of a tree
\item automatically root a gene tree (according to a given species tree)
\end{itemize}

In order to take advantage of these functions, and also for coherence reasons, the Evol extension was implemented as a specific case of the Phylo extension. Or in a more computational language, the EvolTree \mygls{class} inherits from PhyloTree \mygls{class} (note that in the same way, PhyloTree inherits from the main Tree \mygls{class}).

The Evol extension contains two main \myglspl{class}, the EvolTree that as we have seen inherits from the PhyloTree \myglspl{class}, and the Model \myglspl{class} that represents a given evolutionary model (for now, it can be either one of the models proposed by CodeML, or by SLR).

The Evol extension, is available at \myurl{https://github.com/jhcepas/ete/tree/evoltree}, for now, as a branch of ETE. Some documentation can be found at \myurl{http://bioinfo.cipf.es/fransua/ete-evol/tutorial/tutorial_adaptation.html}.

\subsection{General usage}
\label{sec:general-usage}

In this section we are going to quickly overview how to use the Evol extension. Evol trees and alignments are loaded just as PhyloTrees. Here is a short example on how to load a tree together with its alignment and run the free-ratio model:

\begin{python}
  from ete2 import EvolTree

  from ete_dev import EvolTree
  tree = EvolTree("(Orangutan,Human,Chimp);")
  tree.link_to_alignment("""
  >Chimp
  CCC GCA CGA TGG CTC AAT GTA AAG TTA AGA TGC GAA TTG AGA ACA CTA AAA AAA
  TTG GGA CTG GAC GGC TAC AAG GCA GTA AGT CAA TAC GTT AAA GGT CGT GCG ATT
  >Orangutan
  GAT GCA CGA TGG ATC AAT CCA AAG TTA AGA TGC GAA TTG AGA ACT CTG AAA AAA
  TTG GGA CTG GAC GGC TAC AAG GCA GCA AGT CAA TAC GTT AAA GGT CGT AGC TCT
  >Human
  TAC GCA CGA TGG CTC AAC GTA AAA TTA AGA TGT GAA TTA AGG ACG CTC AAA AAA 
  TTG GGA CTG GAC GGC TAC AAG GCA GTA AGT CAA TAC GTT CAA GGT CGT GCC AGT
  """)
  tree.run_model("fb")
  tree.show()

\end{python}

The ``show'' command here works as for PhyloTrees but, additionally, it displays a summary of the selective pressures acting on branches (colored circles appearing at each node in \autoref{fig:sample-fb} which colors and sizes are a function of the corresponding values of $\omega$ estimated by the model).

\begin{figure}[htpb]
  \centering
  \includegraphics[width=\textwidth,trim=0 300 0 20]{figures/tools/sample_fb.pdf}
  \caption[Sample representation of the free-ratio model in an EvolTree.]{
    \textbf{Sample representation of the free-ratio model in an EvolTree.}\\
    Default representation of an EvolTree. Node's sizes and colors are function of the values of $\omega$ for the given branch. For this example, the values found for the sequences under free-ratio model are, for Orangutan $\omega=1.29$, Chimp $\omega=0.28$ and Human $\omega=0.08$.
  }
  \label{fig:sample-fb}
\end{figure}

Also the example above may be ``too simple'' when compared to the number of parameters that have to been set when using directly the CodeML program, the extension allows to modify each one of the parameter proposed by CodeML. As an example, this is the list of default parameters set in the Evol extension for the free-ratio model:

\begin{plain}
         aaDist = 0      |        icode = 0    |           noisy = 0       
      fix_alpha = 1      |    fix_kappa = 0    |         NSsites = 0       
          alpha = 0.0    |        kappa = 2    |       fix_omega = 0       
    fix_blength = 0      |       Malpha = 0    |           omega = 0.7     
      cleandata = 0      |       method = 0    |    RateAncestor = 0       
          clock = 0      |        Mgene = 0    |         runmode = 0       
      CodonFreq = 2      |        model = 1    |         seqtype = 1       
          getSE = 0      |        ncatG = 8    |      Small_Diff = 1e-6    
\end{plain}

Changing one of this parameter can be done easily, suppose we want to set a different starting value for the optimization of $\omega$ (as shown in previous box, by default it is set to 0.7):

\begin{python}
  tree.run("fb", omega=1.2)
\end{python}

In the context of site analysis, the Evol extension also have some features in order to summarize visually the shape of selective pressure along sites. In order to evaluate the selective pressures among sites, we first need to validate positive selection model as being the model with the best fit:

\begin{python}
  tree.run_model("M2")
  tree.run_model("M1")
  tree.get_most_likely("M2", "M1")
\end{python}

Following with the example, the result of the ``get\_most\_likely'' --the p-value of the LRT between the models M1a and M2a-- is bellow 0.05 (P=0.014). Thus ``M2a'' has a better fit, and we can accept the assumption that some site are evolving at $\omega > 1$. As previously mentioned, an other advantage of the Evol extension, lies in the possibility to get an overview of the $\omega$ shape varying along the alignment according to a given evolutionary model (see upper plot in \autoref{fig:sample-M2}). 

\begin{figure}[htpb]
  \centering
  \includegraphics[width=\textwidth,trim=0 90 0 20]{figures/tools/sample_fb_M2_SLR.pdf}
  \caption[Representation of model M2a with CodeML and SLR result.]{
    \textbf{Representation of model M2a with CodeML and SLR result.}\\
    Same representation as in \autoref{fig:sample-fb}, with two additional bar plots representing the values of $\omega$ for each site of the alignment. The plot on the top represents the values of $\omega$ computed under M2a model with the CodeML program, while the plot above sequences represents the values of omega calculated by the SLR program. Colors of the bars represent the significance of belonging to a given class of sites (\textbf{red}: belongs significantly (probability$>$0.99) to class of sites with $\omega>1$, \textbf{orange}: belongs significantly (probability$>$0.95) to class of sites with $\omega>1$, \textbf{blue/cyan}: belongs significantly (probability$>$0.95) to class of sites with $\omega<1$).
  }
  \label{fig:sample-M2}
\end{figure}

In order to confirm the positively selected sites detected by the CodeML program, a good option is to use an other methodology, as the sitewise likelihood-ratio implemented in the SLR program. Through the Evol extension, running SLR program, and displaying a summary result of both, M2a model of CodeML and SLR, would be something like this:

\begin{python}
  tree.run_model("SLR")
  tree.show (histfaces=["M2", "SLR"])
\end{python}

Thus, according to the p-value of the LRT between models ``M2a'' and ``M1a'', and to \autoref{fig:sample-M2}, we can deduce that for our sample alignment we have 2 sites under positive selection, of which 1 is confirmed by the SLR program.

More complex branch models can also be easily defined in order to test different evolutionary hypotheses. For example, if we want to test for significant differences in $\omega$ rates between branches, we will have to mark the tree and compute specific branch models as explained in previous section about \nameref{sec:branch-models} page \pageref{sec:branch-models}.

Each node of an Evol trees is label with an ID that corresponds to the identifier given by CodeML (namely the ``node\_id''). This label are useful to mark a tree. Marks are also inspired in CodeML methodology, that is a hash symbol (\#) followed by a number. To test the hypothesis that Orangutan is significantly evolving at higher rate than Human and Chimp together:

\begin{python}
  tree.mark_tree ([(tree & 'Orangutan').node_id], marks=['#1'])
  tree.write()
\end{python}

The ``write'' command is here to check that our tree has been actually marked (for this example it should be: ``\verb|(Chimp,Orangutan #1,Human);|''). The next step consists in fitting this marked tree to a branch model, and compare it to a null model that can be the ``M0'' model, were all branches have the same value of $\omega$:

\begin{python}
  tree.run_model("b_free")
  tree.mark_tree ([(tree & 'Orangutan').node_id], marks=[''])
  tree.run_model("M0")

  tree.get_most_likely("b_free", "M0")
\end{python}

The p-value of this LRT would be in this case bellow 0.05 (P=0.021), thus Orangutan seems to be evolving at a different rate than the other species. In order to see quickly the values estimated for each part of tree, a summary can be displayed by printing (through the ``print'' function) our branch model:

\begin{python}
  print tree.get_evol_model("b_free")
\end{python}

Output being:

\begin{plain}
   Evolutionary Model b_free:
        log likelihood       : -244.804192
        number of parameters : 6
        sites inference      : None
        sites classes        : None
        branches             : 
           mark: #1  , omega: 1.39095890112, nodes paml_ids: 3
           mark: #0  , omega: 0.123723533087, nodes paml_ids: 1 2
\end{plain}

According to this summary, and to the result of LRT, branches marked with ``\#1'' have a significantly higher value of $\omega$.

Finally, the branch-site test --usually considered the ultimate test of positive selection-- can be computed in a similar way. In this case, we also have to mark the tree in order to differentiate which branches should be considered as foregroud or background branches in branch-site model A (bsA) and branch-site model A1 (bsA1) (see \autoref{sec:branch-site-models}). Lastly we can perform a LRT between these optimized models. As an example, we can apply the branch-site test (test II) in order to see of some sites of our Orangutan's sequence, are under positive selection.

\begin{python}
  tree.mark_tree ([(tree & 'Orangutan').node_id], marks=['#1'])
  tree.run_model("bsA")
  tree.run_model("bsA1")
  tree.get_most_likely("bsA", "bsA1")
\end{python}

The p-value of this LRT is 0.005, allowing thus, the presence of sites evolving at $\omega>1$ specifically in Orangutan's sequence.

\section{Phylemon2.0}
\label{sec:phylemon}

More than a side-product Phylemon raises from the need of evolutionary biologists to easily run, store and compare computational analysis over their data. However, in its last version \cite{Sanchez2011}, some improvements were brought based on,
\begin{inparaenum}[ 1-]
\item the feedback from users and fellows,
\item the advent of new tools in the fields of phylogenetics and study of adaptation,
\item our experience as advanced users of the whole pipeline leading to the detection of selective pressures in protein-coding genes.
\end{inparaenum}

As with previous version, Phylemon is organized in sections, that in their general lines, are following the steps leading to the detection of selective pressures in protein-coding genes we described above (section: \textbf{\nameref{sec:test-evol-scen}}, page \pageref{sec:test-evol-scen}). In this final part of the thesis, we are going to review quickly some of the advances brought by this new version of Phylemon.

\subsection{Alignment}
\label{sec:alignment-2}

The main improvements in Phylemon2.0 around the process of aligning sequences consists basically in the addition of the tools Lagan and M-Lagan \cite{Brudno2003} particularly useful when dealing with long genomic sequences.

Also an effort was made in the sense of the recommendations mentioned in section: \textbf{\nameref{sec:alignment}}, page \pageref{sec:alignment}. In order to ease the achievement of this step we made available a new version of the CDS-protAl tool, that was completely re-written in order to be more efficient and stable, it also offers more options to users. Through the user-friendly web interface, the user can align coding sequences according to their translated amino-acid sequences. It is important to notice that the options proposed in Phylemon2.0 are few in comparison of what the program can do through command-line. CDS-protAl is indeed able to apply the full methodology described bellow, allowing to align a given set of sequences with different tools, merge the resulting alignments, and finally clean them using TrimAl. It is available at \myurl{}.

\subsection{Model selection}
\label{sec:model-testing}

In the context of model testing Phylemon2.0 made available several tools. Most famous being ModelTest \cite{Posada1998} direct successors: jModelTest \cite{Posada2008a} for nucleotide sequences, and ProtTest \cite{Abascal2005} in the case of amino-acids. Additionally a new tool, PhyML-Best-AIC-tree, was implemented paying a special attention to the needs of genomic studies. PhyML-Best-AIC-tree is basically a simplification of jModelTest and ProtTest together, it can deal either with nucleotide or amino-acid sequences but only computes AIC scores. It is specifically designed thinking of its integration in a pipeline. As main feature it has the option to search for the best substitution model in an ``clever'' way. As we have seen in section: \textbf{\nameref{sec:model-test-phyl}} page \pageref{sec:model-test-phyl}, a good approximation in the search for the best substitution model, is to test the fit of each model over a fixed tree. PhyML-Best-AIC-tree can be used in order to compute first this fast approximation for all models, and in second time, run a more precise analysis that involves the optimization of the tree topology but only for the models summing a given weight. The weight of a model being defined as in jModelTest or ProtTest. As for CDS-protAl, more options are available trough command line, and moreover, in the case of PhyML-Best-AIC-tree, a special attention was paid to ease its integration in a pipeline, and all functions can be called independently from another python program -- skipping thus the command line. The program source code is available at \myurl{}

\subsection{Phylogeny}
\label{sec:phylogeny}

In this section, the main advances were done around PhyML \cite{Guindon2003} and MrBayes \cite{Ronquist2003} and consists mainly in an extension of the forms with more options to run these tools and a better integration of their output files in Phylemon framework. MrBayes in particular has now the option to be run non-interactively, and also to build a command block through Phylemon's form. Output trees found can be now browsed directly either in ETE \cite{Huerta-Cepas2010} or in Archaeopteryx \cite{Zmasek}.

\subsection{The Pipeliner}
\label{sec:pipeliner}

This is perhaps one of the greatest improvement in this new release of Phylemon. Phylemon's Pipeliner is a tool designed for enabling users to develop their own pipelines in a friendly modular environment allowing to run multiple gene analyses. The pipeline covers, with a selection of tools, all the steps needed to transform from a given set of sequences to one, or several (as it accepts multiple input files) worthy phylogenetic tree. Moreover, any pipeline created by placing and linking different tools on the Pipeliner ``playground'' can be saved for further analysis, or even exchanged with a collaborator.

\section{Discussion}
\label{sec:discussion-2}

In this last chapter we have overviewed some of the contributions brought as side-products of different works in the context of testing specific evolutionary hypotheses \cite{Lavagnino2011,Martin-Trillo2011,Serra2011,Luke2011,Goncalves2011}. This contributions lie along the pipeline leading to the detection of selective pressures in coding sequences and, most of them consists in very little changes in the classical approaches, nevertheless an effort was made in order to fully integrate them into functional programs and in some cases into a web server.

In all cases, a special attention was paid to the scalability, and to facilitate the use for both, scientists with or without experience in computer sciences. The programming language mainly used was Python \cite{VanRossum2003}, and the choice of this programming language is the result of the balance between 4 major points \begin{inparaenum}[ i)]
  \item the interaction with packages implemented in R \cite{Team2008} -- python allows to call easily R function \cite{Moreira2004},
  \item computation speed versus flexibility -- python a good compromise between the performance of C or java and the flexibility of R or perl \cite{Fourment2008}, 
  \item interactivity, python shell as R shell allows to build an analysis line by line skipping the need of writing a complete working \mygls{script},
  \item its raising popularity among the bioinformatics community \cite{Bassi2007}
\end{inparaenum}.

Finally, I would like to highlight an extra aspect that was considered at the time of implementing these tools, the documentation. A special attention was paid to make these tools scalable and usable, and this effort passes necessarily through the development of comprehensive tutorials and, for advanced users annotation inside the source code. In Phylemon, a full help page is, since version 2.0, describing all the tools and proposing simple exercises in order to better understand the interest and needs of each tool. The Ete's Evol extension, is fully integrated inside ETE, and extends its documentation with specific tutorial, moreover, its source code is fully commented in order to ease the implementation of future extensions and its call from other programs.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../../thesis_main"
%%% End: 
